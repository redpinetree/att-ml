#include <cmath>
#include <iostream>
#include <limits>
#include <sstream>
#include <fstream>
#include <chrono>
#include <tuple>

#include "bond.hpp"
#include "graph_utils.hpp"
#include "mpi_utils.hpp"
#include "site.hpp"

template<typename distribution,typename cmp>
graph<cmp> graph_utils::gen_hypercubic(size_t q,std::vector<size_t> ls,bool pbc,distribution& dist,double beta){
    size_t d=ls.size();
    std::vector<site> vs;
    std::multiset<bond,cmp> es{cmp(q)};
    std::vector<std::tuple<size_t,size_t,double> > orig_ks;
    size_t num_vs=1;
    for(size_t i=0;i<ls.size();i++){
        num_vs*=ls[i];
    }
    for(size_t v1=0;v1<num_vs;v1++){
        vs.push_back(site(q,1));
    }
    for(size_t v1=0;v1<num_vs;v1++){
        size_t v1_idx=v1;
        //identify position of site v1 on hypercubic lattice
        std::vector<size_t> base_coords;
        for(size_t d_idx=0;d_idx<d;d_idx++){
            base_coords.push_back(v1_idx%ls[d_idx]);
            v1_idx/=ls[d_idx];
        }
        vs[v1].coords()=base_coords;
        //add offset (+1 for nearest neighbor)
        for(size_t d_idx=0;d_idx<d;d_idx++){
            //boundary condition
            if(!pbc && (base_coords[d_idx]+1)>=ls[d_idx]){
                continue;
            }
            std::vector<size_t> offsets=base_coords;
            offsets[d_idx]=(offsets[d_idx]+1)%ls[d_idx];
            //compute idx of v2
            size_t v2=0;
            for(size_t d_idx2=d;d_idx2>0;d_idx2--){
                v2=(v2*ls[d_idx2-1])+offsets[d_idx2-1];
            }
            //note the rescaling, for the bimodal case which can only be generated by discrete_distribution returning 0 or 1
            //input distributions should be scaled appropriately!
            double k=(2*dist(mpi_utils::prng))-1;
            orig_ks.push_back(std::make_tuple(v1,v2,k));
            vs[v1].orig_ks_idxs().push_back(orig_ks.size()-1);
            vs[v2].orig_ks_idxs().push_back(orig_ks.size()-1);
            k*=beta;
            array3d<double> w(q,q,1); //bond is still as weight matrix
            for(size_t i=0;i<q;i++){
                for(size_t j=0;j<q;j++){
                    w.at(i,j,0)=log((i==j)?(1/(q+(q*(q-1)*exp(-k)))):(1/((q*exp(k))+(q*(q-1)))));
                }
            }
            es.insert(bond(v1,v2,0,w));
            vs[v1].adj().insert(bond(v1,v2,0,w));
            vs[v2].adj().insert(bond(v1,v2,0,w));
        }
    }
    graph<cmp> g(vs,es,beta,orig_ks);
    g.dims()=ls;
    return g;
}
template graph<bmi_comparator> graph_utils::gen_hypercubic<std::normal_distribution<double>,bmi_comparator>(size_t,std::vector<size_t>,bool,std::normal_distribution<double>&,double);
template graph<bmi_comparator> graph_utils::gen_hypercubic<std::discrete_distribution<int>,bmi_comparator>(size_t,std::vector<size_t>,bool,std::discrete_distribution<int>&,double);
template graph<bmi_comparator> graph_utils::gen_hypercubic<std::uniform_real_distribution<double>,bmi_comparator>(size_t,std::vector<size_t>,bool,std::uniform_real_distribution<double>&,double);

//only for potts model... should have new format to store weight matrices too
template<typename cmp>
graph<cmp> graph_utils::load_graph(std::string fn,size_t q,double beta){
    std::ifstream ifs;
    ifs.open(fn);
    std::string line;
    size_t num_vs,num_es;
    std::vector<site> vs;
    std::multiset<bond,cmp> es{cmp(q)};
    std::vector<std::tuple<size_t,size_t,double> > orig_ks;
    std::getline(ifs,line);
    std::stringstream first_line_ss(line);
    first_line_ss>>num_vs>>num_es;
    for(size_t i=0;i<num_vs;i++){
        vs.push_back(site(q,1));
    }
    while(std::getline(ifs,line)){
        std::stringstream line_ss(line);
        size_t v1,v2;
        double k;
        line_ss>>v1>>v2>>k;
        k/=1e5;
        orig_ks.push_back(std::make_tuple(v1,v2,k));
        vs[v1].orig_ks_idxs().push_back(orig_ks.size()-1);
        vs[v2].orig_ks_idxs().push_back(orig_ks.size()-1);
        k*=beta;
        array3d<double> w(q,q,1); //bond is still as weight matrix
        for(size_t i=0;i<q;i++){
            for(size_t j=0;j<q;j++){
                w.at(i,j,0)=log((i==j)?(1/(q+(q*(q-1)*exp(-k)))):(1/((q*exp(k))+(q*(q-1)))));
            }
        }
        es.insert(bond(v1,v2,0,w));
        vs[v1].adj().insert(bond(v1,v2,0,w));
        vs[v2].adj().insert(bond(v1,v2,0,w));
    }
    return graph<cmp>(vs,es,beta,orig_ks);
}
template graph<bmi_comparator> graph_utils::load_graph(std::string,size_t,double);

template<typename distribution,typename cmp>
graph<cmp> graph_utils::init_pbttn(size_t idim,size_t tdim,size_t r_max,std::vector<size_t> ls,distribution& dist,double beta){
    std::uniform_real_distribution<> unif_dist(1e-10,1.0);
    size_t d=ls.size();
    std::vector<site> vs;
    std::multiset<bond,cmp> es{cmp(idim)};
    std::vector<std::tuple<size_t,size_t,double> > orig_ks;
    size_t num_vs=1;
    for(size_t i=0;i<ls.size();i++){
        num_vs*=ls[i];
    }
    for(size_t v1=0;v1<num_vs;v1++){
        vs.push_back(site(idim,1));
        vs[v1].p_k()=std::vector<double>(idim,1/(double) idim);
    }
    //generate couplings
    for(size_t v1=0;v1<num_vs;v1++){
        size_t v1_idx=v1;
        //identify position of site v1 on hypercubic lattice
        std::vector<size_t> base_coords;
        for(size_t d_idx=0;d_idx<d;d_idx++){
            base_coords.push_back(v1_idx%ls[d_idx]);
            v1_idx/=ls[d_idx];
        }
        vs[v1].coords()=base_coords;
        //add offset (+1 for nearest neighbor)
        for(size_t d_idx=0;d_idx<d;d_idx++){
            //boundary condition
            if((base_coords[d_idx]+1)>=ls[d_idx]){
                continue;
            }
            std::vector<size_t> offsets=base_coords;
            offsets[d_idx]=(offsets[d_idx]+1)%ls[d_idx];
            //compute idx of v2
            size_t v2=0;
            for(size_t d_idx2=d;d_idx2>0;d_idx2--){
                v2=(v2*ls[d_idx2-1])+offsets[d_idx2-1];
            }
            //note the rescaling, for the bimodal case which can only be generated by discrete_distribution returning 0 or 1
            //input distributions should be scaled appropriately!
            double k=(2*dist(mpi_utils::prng))-1;
            orig_ks.push_back(std::make_tuple(v1,v2,k));
            vs[v1].orig_ks_idxs().push_back(orig_ks.size()-1);
            vs[v2].orig_ks_idxs().push_back(orig_ks.size()-1);
        }
    }
    
    size_t num_tensors=num_vs-1;
    size_t counter=0;
    for(size_t t_idx=0;t_idx<num_tensors;t_idx++){
        size_t v1=counter;
        size_t v2=counter+1;
        
        //note the rescaling, for the bimodal case which can only be generated by discrete_distribution returning 0 or 1
        //input distributions should be scaled appropriately!
        size_t r_i=vs[v1].rank();
        size_t r_j=vs[v2].rank();
        size_t r_k=(r_i*r_j>r_max)?r_max:r_i*r_j;
        if(t_idx==num_tensors-1){ //for the top tensor
            if(tdim!=0){ //tdim==0 means it was not specified
                r_k=tdim;
            }
        }
        size_t depth=((vs[v1].depth()>vs[v2].depth())?vs[v1].depth():vs[v2].depth())+1;
        vs.push_back(site(r_k,vs[v1].vol()+vs[v2].vol(),depth,v1,v2));
        vs[vs.size()-1].p_k()=std::vector<double>(r_k,1/(double) r_k);
        
        array3d<double> w(r_i,r_j,r_k); //bond is still as weight matrix
        std::vector<double> sum_addends;
        for(size_t i=0;i<r_i;i++){
            for(size_t j=0;j<r_j;j++){
                for(size_t k=0;k<r_k;k++){
                    w.at(i,j,k)=unif_dist(mpi_utils::prng);
                    sum_addends.push_back(w.at(i,j,k));
                }
            }
        }
        double sum=vec_add_float(sum_addends);
        for(size_t i=0;i<r_i;i++){
            for(size_t j=0;j<r_j;j++){
                for(size_t k=0;k<r_k;k++){
                    w.at(i,j,k)/=sum;
                }
            }
        }
        bond b(v1,v2,depth,w);
        b.order()=num_vs+t_idx;
        b.virt_count()=vs[v1].virt()+vs[v2].virt();
        b.todo()=0;
        b.bmi()=std::numeric_limits<double>::quiet_NaN();
        es.insert(b);
        vs[v1].u_idx()=vs.size()-1;
        vs[v2].u_idx()=vs.size()-1;
        // std::cout<<(std::string) b<<"\n";g.vs()[current.v1()].p_k()
        
        
        counter+=2;
    }
    vs[vs.size()-1].u_idx()=0;
    vs[vs.size()-1].bmi()=std::numeric_limits<double>::quiet_NaN();
    
    // for(size_t i=0;i<orig_ks.size();i++){
        // size_t v1=std::get<0>(orig_ks[i]);
        // size_t v2=std::get<1>(orig_ks[i]);
        // size_t k=std::get<2>(orig_ks[i]);
        // std::cout<<v1<<" "<<v2<<" "<<k<<"\n";
    // }
    
    // for(size_t n=0;n<vs.size();n++){
        // std::cout<<n<<":\n";
        // for(size_t i=0;i<vs[n].orig_ks_idxs().size();i++){
            // size_t v1=std::get<0>(orig_ks[vs[n].orig_ks_idxs()[i]]);
            // size_t v2=std::get<1>(orig_ks[vs[n].orig_ks_idxs()[i]]);
            // size_t k=std::get<2>(orig_ks[vs[n].orig_ks_idxs()[i]]);
            // std::cout<<"\t"<<v1<<" "<<v2<<" "<<k<<"\n";
        // }
    // }
    
    graph<cmp> g(vs,es,beta,orig_ks);
    g.n_phys_sites()=num_vs;
    // std::cout<<(std::string) g<<"\n";
    // exit(1);
    g.dims()=ls;
    return g;
}
template graph<bmi_comparator> graph_utils::init_pbttn<std::normal_distribution<double>,bmi_comparator>(size_t,size_t,size_t,std::vector<size_t>,std::normal_distribution<double>&,double);
template graph<bmi_comparator> graph_utils::init_pbttn<std::discrete_distribution<int>,bmi_comparator>(size_t,size_t,size_t,std::vector<size_t>,std::discrete_distribution<int>&,double);
template graph<bmi_comparator> graph_utils::init_pbttn<std::uniform_real_distribution<double>,bmi_comparator>(size_t,size_t,size_t,std::vector<size_t>,std::uniform_real_distribution<double>&,double);

template<typename distribution,typename cmp>
graph<cmp> graph_utils::init_pbttn(size_t idim,size_t r_max,std::vector<size_t> ls,distribution& dist,double beta){
    return graph_utils::init_pbttn<distribution,cmp>(idim,0,r_max,ls,dist,beta);
}
template graph<bmi_comparator> graph_utils::init_pbttn<std::normal_distribution<double>,bmi_comparator>(size_t,size_t,std::vector<size_t>,std::normal_distribution<double>&,double);
template graph<bmi_comparator> graph_utils::init_pbttn<std::discrete_distribution<int>,bmi_comparator>(size_t,size_t,std::vector<size_t>,std::discrete_distribution<int>&,double);
template graph<bmi_comparator> graph_utils::init_pbttn<std::uniform_real_distribution<double>,bmi_comparator>(size_t,size_t,std::vector<size_t>,std::uniform_real_distribution<double>&,double);

template<typename distribution,typename cmp>
graph<cmp> graph_utils::init_mps(size_t idim,size_t tdim,size_t r_max,std::vector<size_t> ls,distribution& dist,double beta){
    std::uniform_real_distribution<> unif_dist(1e-10,1.0);
    size_t d=ls.size();
    std::vector<site> vs;
    std::multiset<bond,cmp> es{cmp(idim)};
    std::vector<std::tuple<size_t,size_t,double> > orig_ks;
    size_t num_vs=1;
    for(size_t i=0;i<ls.size();i++){
        num_vs*=ls[i];
    }
    for(size_t v1=0;v1<num_vs;v1++){
        vs.push_back(site(idim,1));
        vs[v1].p_k()=std::vector<double>(idim,1/(double) idim);
    }
    //generate couplings
    for(size_t v1=0;v1<num_vs;v1++){
        size_t v1_idx=v1;
        //identify position of site v1 on hypercubic lattice
        std::vector<size_t> base_coords;
        for(size_t d_idx=0;d_idx<d;d_idx++){
            base_coords.push_back(v1_idx%ls[d_idx]);
            v1_idx/=ls[d_idx];
        }
        vs[v1].coords()=base_coords;
        //add offset (+1 for nearest neighbor)
        for(size_t d_idx=0;d_idx<d;d_idx++){
            //boundary condition
            if((base_coords[d_idx]+1)>=ls[d_idx]){
                continue;
            }
            std::vector<size_t> offsets=base_coords;
            offsets[d_idx]=(offsets[d_idx]+1)%ls[d_idx];
            //compute idx of v2
            size_t v2=0;
            for(size_t d_idx2=d;d_idx2>0;d_idx2--){
                v2=(v2*ls[d_idx2-1])+offsets[d_idx2-1];
            }
            //note the rescaling, for the bimodal case which can only be generated by discrete_distribution returning 0 or 1
            //input distributions should be scaled appropriately!
            double k=(2*dist(mpi_utils::prng))-1;
            orig_ks.push_back(std::make_tuple(v1,v2,k));
            vs[v1].orig_ks_idxs().push_back(orig_ks.size()-1);
            vs[v2].orig_ks_idxs().push_back(orig_ks.size()-1);
        }
    }
    
    size_t num_tensors=num_vs-1;
    size_t phys_site_counter=0;
    size_t virt_site_counter=num_vs-1;
    size_t depth=1;
    for(size_t t_idx=0;t_idx<num_vs-1;t_idx++){
        size_t v1=phys_site_counter;
        size_t v2=(t_idx==0)?++phys_site_counter:virt_site_counter;
        
        //note the rescaling, for the bimodal case which can only be generated by discrete_distribution returning 0 or 1
        //input distributions should be scaled appropriately!
        size_t r_i=vs[v1].rank();
        size_t r_j=vs[v2].rank();
        size_t r_k=(r_i*r_j>r_max)?r_max:r_i*r_j;
        if(t_idx==num_tensors-1){ //for the top tensor
            if(tdim!=0){ //tdim==0 means it was not specified
                r_k=tdim;
            }
        }
        vs.push_back(site(r_k,vs[v1].vol()+vs[v2].vol(),depth,v1,v2));
        vs[vs.size()-1].p_k()=std::vector<double>(r_k,1/(double) r_k);
        
        array3d<double> w(r_i,r_j,r_k); //bond is still as weight matrix
        std::vector<double> sum_addends;
        for(size_t i=0;i<r_i;i++){
            for(size_t j=0;j<r_j;j++){
                for(size_t k=0;k<r_k;k++){
                    w.at(i,j,k)=unif_dist(mpi_utils::prng);
                    sum_addends.push_back(w.at(i,j,k));
                }
            }
        }
        double sum=vec_add_float(sum_addends);
        for(size_t i=0;i<r_i;i++){
            for(size_t j=0;j<r_j;j++){
                for(size_t k=0;k<r_k;k++){
                    w.at(i,j,k)/=sum;
                }
            }
        }
        bond b(v1,v2,depth,w);
        b.order()=num_vs+t_idx;
        b.virt_count()=vs[v1].virt()+vs[v2].virt();
        b.todo()=0;
        b.bmi()=std::numeric_limits<double>::quiet_NaN();
        es.insert(b);
        vs[v1].u_idx()=vs.size()-1;
        vs[v2].u_idx()=vs.size()-1;
        // std::cout<<(std::string) b<<"\n";g.vs()[current.v1()].p_k()
        
        
        phys_site_counter++;
        virt_site_counter++;
        depth++;
    }
    vs[vs.size()-1].u_idx()=0;
    vs[vs.size()-1].bmi()=std::numeric_limits<double>::quiet_NaN();
    
    // for(size_t i=0;i<orig_ks.size();i++){
        // size_t v1=std::get<0>(orig_ks[i]);
        // size_t v2=std::get<1>(orig_ks[i]);
        // size_t k=std::get<2>(orig_ks[i]);
        // std::cout<<v1<<" "<<v2<<" "<<k<<"\n";
    // }
    
    // for(size_t n=0;n<vs.size();n++){
        // std::cout<<n<<":\n";
        // for(size_t i=0;i<vs[n].orig_ks_idxs().size();i++){
            // size_t v1=std::get<0>(orig_ks[vs[n].orig_ks_idxs()[i]]);
            // size_t v2=std::get<1>(orig_ks[vs[n].orig_ks_idxs()[i]]);
            // size_t k=std::get<2>(orig_ks[vs[n].orig_ks_idxs()[i]]);
            // std::cout<<"\t"<<v1<<" "<<v2<<" "<<k<<"\n";
        // }
    // }
    
    graph<cmp> g(vs,es,beta,orig_ks);
    g.n_phys_sites()=num_vs;
    // std::cout<<(std::string) g<<"\n";
    // exit(1);
    g.dims()=ls;
    return g;
}
template graph<bmi_comparator> graph_utils::init_mps<std::normal_distribution<double>,bmi_comparator>(size_t,size_t,size_t,std::vector<size_t>,std::normal_distribution<double>&,double);
template graph<bmi_comparator> graph_utils::init_mps<std::discrete_distribution<int>,bmi_comparator>(size_t,size_t,size_t,std::vector<size_t>,std::discrete_distribution<int>&,double);
template graph<bmi_comparator> graph_utils::init_mps<std::uniform_real_distribution<double>,bmi_comparator>(size_t,size_t,size_t,std::vector<size_t>,std::uniform_real_distribution<double>&,double);

template<typename distribution,typename cmp>
graph<cmp> graph_utils::init_mps(size_t idim,size_t r_max,std::vector<size_t> ls,distribution& dist,double beta){
    return graph_utils::init_mps<distribution,cmp>(idim,0,r_max,ls,dist,beta);
}
template graph<bmi_comparator> graph_utils::init_mps<std::normal_distribution<double>,bmi_comparator>(size_t,size_t,std::vector<size_t>,std::normal_distribution<double>&,double);
template graph<bmi_comparator> graph_utils::init_mps<std::discrete_distribution<int>,bmi_comparator>(size_t,size_t,std::vector<size_t>,std::discrete_distribution<int>&,double);
template graph<bmi_comparator> graph_utils::init_mps<std::uniform_real_distribution<double>,bmi_comparator>(size_t,size_t,std::vector<size_t>,std::uniform_real_distribution<double>&,double);


template<typename distribution,typename cmp>
graph<cmp> graph_utils::init_rand(size_t idim,size_t tdim,size_t r_max,std::vector<size_t> ls,distribution& dist,double beta){
    std::uniform_real_distribution<> unif_dist(1e-10,1.0);
    size_t d=ls.size();
    std::vector<site> vs;
    std::multiset<bond,cmp> es{cmp(idim)};
    std::vector<std::tuple<size_t,size_t,double> > orig_ks;
    size_t num_vs=1;
    for(size_t i=0;i<ls.size();i++){
        num_vs*=ls[i];
    }
    for(size_t v1=0;v1<num_vs;v1++){
        vs.push_back(site(idim,1));
        vs[v1].p_k()=std::vector<double>(idim,1/(double) idim);
        vs[v1].depth()=0;
    }
    //generate couplings
    for(size_t v1=0;v1<num_vs;v1++){
        size_t v1_idx=v1;
        //identify position of site v1 on hypercubic lattice
        std::vector<size_t> base_coords;
        for(size_t d_idx=0;d_idx<d;d_idx++){
            base_coords.push_back(v1_idx%ls[d_idx]);
            v1_idx/=ls[d_idx];
        }
        vs[v1].coords()=base_coords;
        //add offset (+1 for nearest neighbor)
        for(size_t d_idx=0;d_idx<d;d_idx++){
            //boundary condition
            if((base_coords[d_idx]+1)>=ls[d_idx]){
                continue;
            }
            std::vector<size_t> offsets=base_coords;
            offsets[d_idx]=(offsets[d_idx]+1)%ls[d_idx];
            //compute idx of v2
            size_t v2=0;
            for(size_t d_idx2=d;d_idx2>0;d_idx2--){
                v2=(v2*ls[d_idx2-1])+offsets[d_idx2-1];
            }
            //note the rescaling, for the bimodal case which can only be generated by discrete_distribution returning 0 or 1
            //input distributions should be scaled appropriately!
            double k=(2*dist(mpi_utils::prng))-1;
            orig_ks.push_back(std::make_tuple(v1,v2,k));
            vs[v1].orig_ks_idxs().push_back(orig_ks.size()-1);
            vs[v2].orig_ks_idxs().push_back(orig_ks.size()-1);
        }
    }
    
    size_t num_tensors=num_vs-1;
    size_t virt_site_counter=num_vs;
    std::set<size_t> available_idxs;
    for(size_t i=0;i<num_vs;i++){
        available_idxs.insert(i);
    }
    for(size_t t_idx=0;t_idx<num_vs-1;t_idx++){
        size_t v1=*(available_idxs.begin());
        available_idxs.erase(v1);
        std::uniform_int_distribution<size_t> pdf(0,available_idxs.size()-1);
        size_t rand_idx=pdf(mpi_utils::prng);
        auto it=available_idxs.begin();
        for(size_t i=0;i<rand_idx;i++){
            ++it;
        }
        size_t v2=(*it);
        if(v1>v2){
            size_t swap=v1;
            v1=v2;
            v2=swap;
        }
        size_t a=available_idxs.erase(v2);
        available_idxs.insert(virt_site_counter);
        virt_site_counter++;
        size_t depth=((vs[v1].depth()>vs[v2].depth())?vs[v1].depth():vs[v2].depth())+1;
        
        //note the rescaling, for the bimodal case which can only be generated by discrete_distribution returning 0 or 1
        //input distributions should be scaled appropriately!
        size_t r_i=vs[v1].rank();
        size_t r_j=vs[v2].rank();
        size_t r_k=(r_i*r_j>r_max)?r_max:r_i*r_j;
        if(t_idx==num_tensors-1){ //for the top tensor
            if(tdim!=0){ //tdim==0 means it was not specified
                r_k=tdim;
            }
        }
        vs.push_back(site(r_k,vs[v1].vol()+vs[v2].vol(),depth,v1,v2));
        vs[vs.size()-1].p_k()=std::vector<double>(r_k,1/(double) r_k);
        
        array3d<double> w(r_i,r_j,r_k); //bond is still as weight matrix
        std::vector<double> sum_addends;
        for(size_t i=0;i<r_i;i++){
            for(size_t j=0;j<r_j;j++){
                for(size_t k=0;k<r_k;k++){
                    w.at(i,j,k)=unif_dist(mpi_utils::prng);
                    sum_addends.push_back(w.at(i,j,k));
                }
            }
        }
        double sum=vec_add_float(sum_addends);
        for(size_t i=0;i<r_i;i++){
            for(size_t j=0;j<r_j;j++){
                for(size_t k=0;k<r_k;k++){
                    w.at(i,j,k)/=sum;
                }
            }
        }
        bond b(v1,v2,depth,w);
        b.order()=num_vs+t_idx;
        b.virt_count()=vs[v1].virt()+vs[v2].virt();
        b.todo()=0;
        b.bmi()=std::numeric_limits<double>::quiet_NaN();
        es.insert(b);
        vs[v1].u_idx()=vs.size()-1;
        vs[v2].u_idx()=vs.size()-1;
        // std::cout<<(std::string) b<<"\n";g.vs()[current.v1()].p_k()
    }
    vs[vs.size()-1].u_idx()=0;
    vs[vs.size()-1].bmi()=std::numeric_limits<double>::quiet_NaN();
    
    // for(size_t i=0;i<orig_ks.size();i++){
        // size_t v1=std::get<0>(orig_ks[i]);
        // size_t v2=std::get<1>(orig_ks[i]);
        // double k=std::get<2>(orig_ks[i]);
        // std::cout<<v1<<" "<<v2<<" "<<k<<"\n";
    // }
    
    // for(size_t n=0;n<vs.size();n++){
        // std::cout<<n<<":\n";
        // for(size_t i=0;i<vs[n].orig_ks_idxs().size();i++){
            // size_t v1=std::get<0>(orig_ks[vs[n].orig_ks_idxs()[i]]);
            // size_t v2=std::get<1>(orig_ks[vs[n].orig_ks_idxs()[i]]);
            // double k=std::get<2>(orig_ks[vs[n].orig_ks_idxs()[i]]);
            // std::cout<<"\t"<<v1<<" "<<v2<<" "<<k<<"\n";
        // }
    // }
    
    graph<cmp> g(vs,es,beta,orig_ks);
    g.n_phys_sites()=num_vs;
    // std::cout<<(std::string) g<<"\n";
    // exit(1);
    g.dims()=ls;
    return g;
}
template graph<bmi_comparator> graph_utils::init_rand<std::normal_distribution<double>,bmi_comparator>(size_t,size_t,size_t,std::vector<size_t>,std::normal_distribution<double>&,double);
template graph<bmi_comparator> graph_utils::init_rand<std::discrete_distribution<int>,bmi_comparator>(size_t,size_t,size_t,std::vector<size_t>,std::discrete_distribution<int>&,double);
template graph<bmi_comparator> graph_utils::init_rand<std::uniform_real_distribution<double>,bmi_comparator>(size_t,size_t,size_t,std::vector<size_t>,std::uniform_real_distribution<double>&,double);

template<typename distribution,typename cmp>
graph<cmp> graph_utils::init_rand(size_t idim,size_t r_max,std::vector<size_t> ls,distribution& dist,double beta){
    return graph_utils::init_rand<distribution,cmp>(idim,0,r_max,ls,dist,beta);
}
template graph<bmi_comparator> graph_utils::init_rand<std::normal_distribution<double>,bmi_comparator>(size_t,size_t,std::vector<size_t>,std::normal_distribution<double>&,double);
template graph<bmi_comparator> graph_utils::init_rand<std::discrete_distribution<int>,bmi_comparator>(size_t,size_t,std::vector<size_t>,std::discrete_distribution<int>&,double);
template graph<bmi_comparator> graph_utils::init_rand<std::uniform_real_distribution<double>,bmi_comparator>(size_t,size_t,std::vector<size_t>,std::uniform_real_distribution<double>&,double);