#include <cmath>
#include <iostream>
#include <sstream>
#include <fstream>
#include <chrono>
#include <tuple>

#include "bond.hpp"
#include "graph_utils.hpp"
#include "mpi_utils.hpp"
#include "site.hpp"

template<typename cmp>
graph<cmp> graph_utils::init_pbttn(size_t idim,size_t tdim,size_t r_max,std::vector<size_t> ls){
    std::uniform_real_distribution<> unif_dist(1e-10,1.0);
    size_t d=ls.size();
    std::vector<site> vs;
    std::multiset<bond,cmp> es{cmp(idim)};
    size_t num_vs=1;
    for(size_t i=0;i<ls.size();i++){
        num_vs*=ls[i];
    }
    for(size_t v1=0;v1<num_vs;v1++){
        vs.push_back(site(idim,1));
        vs[v1].p_k()=std::vector<double>(idim,1/(double) idim);
    }
    //generate couplings
    for(size_t v1=0;v1<num_vs;v1++){
        size_t v1_idx=v1;
        //identify position of site v1 on hypercubic lattice
        std::vector<size_t> base_coords;
        for(size_t d_idx=0;d_idx<d;d_idx++){
            base_coords.push_back(v1_idx%ls[d_idx]);
            v1_idx/=ls[d_idx];
        }
        //add offset (+1 for nearest neighbor)
        for(size_t d_idx=0;d_idx<d;d_idx++){
            //boundary condition
            if((base_coords[d_idx]+1)>=ls[d_idx]){
                continue;
            }
            std::vector<size_t> offsets=base_coords;
            offsets[d_idx]=(offsets[d_idx]+1)%ls[d_idx];
            //compute idx of v2
            size_t v2=0;
            for(size_t d_idx2=d;d_idx2>0;d_idx2--){
                v2=(v2*ls[d_idx2-1])+offsets[d_idx2-1];
            }
        }
    }
    
    size_t num_tensors=num_vs-1;
    size_t counter=0;
    for(size_t t_idx=0;t_idx<num_tensors;t_idx++){
        size_t v1=counter;
        size_t v2=counter+1;
        
        //note the rescaling, for the bimodal case which can only be generated by discrete_distribution returning 0 or 1
        //input distributions should be scaled appropriately!
        size_t r_i=vs[v1].rank();
        size_t r_j=vs[v2].rank();
        size_t r_k=(r_i*r_j>r_max)?r_max:r_i*r_j;
        if(t_idx==num_tensors-1){ //for the top tensor
            if(tdim!=0){ //tdim==0 means it was not specified
                r_k=tdim;
            }
        }
        size_t depth=((vs[v1].depth()>vs[v2].depth())?vs[v1].depth():vs[v2].depth())+1;
        vs.push_back(site(r_k,vs[v1].vol()+vs[v2].vol(),depth,v1,v2));
        vs[vs.size()-1].p_k()=std::vector<double>(r_k,1/(double) r_k);
        
        array3d<double> w(r_i,r_j,r_k); //bond is still as weight matrix
        std::vector<double> sum_addends;
        for(size_t i=0;i<r_i;i++){
            for(size_t j=0;j<r_j;j++){
                for(size_t k=0;k<r_k;k++){
                    w.at(i,j,k)=unif_dist(mpi_utils::prng);
                    sum_addends.push_back(w.at(i,j,k));
                }
            }
        }
        double sum=vec_add_float(sum_addends);
        for(size_t i=0;i<r_i;i++){
            for(size_t j=0;j<r_j;j++){
                for(size_t k=0;k<r_k;k++){
                    w.at(i,j,k)/=sum;
                }
            }
        }
        bond b(v1,v2,depth,w);
        b.order()=num_vs+t_idx;
        b.virt_count()=vs[v1].virt()+vs[v2].virt();
        b.todo()=0;
        b.bmi()=std::numeric_limits<double>::quiet_NaN();
        es.insert(b);
        vs[vs.size()-1].p_bond()=b;
        vs[v1].u_idx()=vs.size()-1;
        vs[v2].u_idx()=vs.size()-1;
        // std::cout<<(std::string) b<<"\n";g.vs()[current.v1()].p_k()
        
        
        counter+=2;
    }
    vs[vs.size()-1].u_idx()=0;
    vs[vs.size()-1].bmi()=std::numeric_limits<double>::quiet_NaN();
    
    graph<cmp> g(vs,es);
    g.n_phys_sites()=num_vs;
    // std::cout<<(std::string) g<<"\n";
    // exit(1);
    return g;
}
template graph<bmi_comparator> graph_utils::init_pbttn(size_t,size_t,size_t,std::vector<size_t>);

template<typename cmp>
graph<cmp> graph_utils::init_pbttn(size_t idim,size_t r_max,std::vector<size_t> ls){
    return graph_utils::init_pbttn<cmp>(idim,0,r_max,ls);
}
template graph<bmi_comparator> graph_utils::init_pbttn(size_t,size_t,std::vector<size_t>);

template<typename cmp>
graph<cmp> graph_utils::init_mps(size_t idim,size_t tdim,size_t r_max,std::vector<size_t> ls){
    std::uniform_real_distribution<> unif_dist(1e-10,1.0);
    size_t d=ls.size();
    std::vector<site> vs;
    std::multiset<bond,cmp> es{cmp(idim)};
    size_t num_vs=1;
    for(size_t i=0;i<ls.size();i++){
        num_vs*=ls[i];
    }
    for(size_t v1=0;v1<num_vs;v1++){
        vs.push_back(site(idim,1));
        vs[v1].p_k()=std::vector<double>(idim,1/(double) idim);
    }
    //generate couplings
    for(size_t v1=0;v1<num_vs;v1++){
        size_t v1_idx=v1;
        //identify position of site v1 on hypercubic lattice
        std::vector<size_t> base_coords;
        for(size_t d_idx=0;d_idx<d;d_idx++){
            base_coords.push_back(v1_idx%ls[d_idx]);
            v1_idx/=ls[d_idx];
        }
        //add offset (+1 for nearest neighbor)
        for(size_t d_idx=0;d_idx<d;d_idx++){
            //boundary condition
            if((base_coords[d_idx]+1)>=ls[d_idx]){
                continue;
            }
            std::vector<size_t> offsets=base_coords;
            offsets[d_idx]=(offsets[d_idx]+1)%ls[d_idx];
            //compute idx of v2
            size_t v2=0;
            for(size_t d_idx2=d;d_idx2>0;d_idx2--){
                v2=(v2*ls[d_idx2-1])+offsets[d_idx2-1];
            }
        }
    }
    
    size_t num_tensors=num_vs-1;
    size_t phys_site_counter=0;
    size_t virt_site_counter=num_vs-1;
    size_t depth=1;
    for(size_t t_idx=0;t_idx<num_vs-1;t_idx++){
        size_t v1=phys_site_counter;
        size_t v2=(t_idx==0)?++phys_site_counter:virt_site_counter;
        
        //note the rescaling, for the bimodal case which can only be generated by discrete_distribution returning 0 or 1
        //input distributions should be scaled appropriately!
        size_t r_i=vs[v1].rank();
        size_t r_j=vs[v2].rank();
        size_t r_k=(r_i*r_j>r_max)?r_max:r_i*r_j;
        if(t_idx==num_tensors-1){ //for the top tensor
            if(tdim!=0){ //tdim==0 means it was not specified
                r_k=tdim;
            }
        }
        vs.push_back(site(r_k,vs[v1].vol()+vs[v2].vol(),depth,v1,v2));
        vs[vs.size()-1].p_k()=std::vector<double>(r_k,1/(double) r_k);
        
        array3d<double> w(r_i,r_j,r_k); //bond is still as weight matrix
        std::vector<double> sum_addends;
        for(size_t i=0;i<r_i;i++){
            for(size_t j=0;j<r_j;j++){
                for(size_t k=0;k<r_k;k++){
                    w.at(i,j,k)=unif_dist(mpi_utils::prng);
                    sum_addends.push_back(w.at(i,j,k));
                }
            }
        }
        double sum=vec_add_float(sum_addends);
        for(size_t i=0;i<r_i;i++){
            for(size_t j=0;j<r_j;j++){
                for(size_t k=0;k<r_k;k++){
                    w.at(i,j,k)/=sum;
                }
            }
        }
        bond b(v1,v2,depth,w);
        b.order()=num_vs+t_idx;
        b.virt_count()=vs[v1].virt()+vs[v2].virt();
        b.todo()=0;
        b.bmi()=std::numeric_limits<double>::quiet_NaN();
        es.insert(b);
        vs[vs.size()-1].p_bond()=b;
        vs[v1].u_idx()=vs.size()-1;
        vs[v2].u_idx()=vs.size()-1;
        // std::cout<<(std::string) b<<"\n";g.vs()[current.v1()].p_k()
        
        
        phys_site_counter++;
        virt_site_counter++;
        depth++;
    }
    vs[vs.size()-1].u_idx()=0;
    vs[vs.size()-1].bmi()=std::numeric_limits<double>::quiet_NaN();
    
    graph<cmp> g(vs,es);
    g.n_phys_sites()=num_vs;
    // std::cout<<(std::string) g<<"\n";
    // exit(1);
    return g;
}
template graph<bmi_comparator> graph_utils::init_mps(size_t,size_t,size_t,std::vector<size_t>);

template<typename cmp>
graph<cmp> graph_utils::init_mps(size_t idim,size_t r_max,std::vector<size_t> ls){
    return graph_utils::init_mps<cmp>(idim,0,r_max,ls);
}
template graph<bmi_comparator> graph_utils::init_mps(size_t,size_t,std::vector<size_t>);

template<typename cmp>
graph<cmp> graph_utils::init_rand(size_t idim,size_t tdim,size_t r_max,std::vector<size_t> ls){
    std::uniform_real_distribution<> unif_dist(1e-10,1.0);
    size_t d=ls.size();
    std::vector<site> vs;
    std::multiset<bond,cmp> es{cmp(idim)};
    size_t num_vs=1;
    for(size_t i=0;i<ls.size();i++){
        num_vs*=ls[i];
    }
    for(size_t v1=0;v1<num_vs;v1++){
        vs.push_back(site(idim,1));
        vs[v1].p_k()=std::vector<double>(idim,1/(double) idim);
        vs[v1].depth()=0;
    }
    //generate couplings
    for(size_t v1=0;v1<num_vs;v1++){
        size_t v1_idx=v1;
        //identify position of site v1 on hypercubic lattice
        std::vector<size_t> base_coords;
        for(size_t d_idx=0;d_idx<d;d_idx++){
            base_coords.push_back(v1_idx%ls[d_idx]);
            v1_idx/=ls[d_idx];
        }
        //add offset (+1 for nearest neighbor)
        for(size_t d_idx=0;d_idx<d;d_idx++){
            //boundary condition
            if((base_coords[d_idx]+1)>=ls[d_idx]){
                continue;
            }
            std::vector<size_t> offsets=base_coords;
            offsets[d_idx]=(offsets[d_idx]+1)%ls[d_idx];
            //compute idx of v2
            size_t v2=0;
            for(size_t d_idx2=d;d_idx2>0;d_idx2--){
                v2=(v2*ls[d_idx2-1])+offsets[d_idx2-1];
            }
        }
    }
    
    size_t num_tensors=num_vs-1;
    size_t virt_site_counter=num_vs;
    std::set<size_t> available_idxs;
    for(size_t i=0;i<num_vs;i++){
        available_idxs.insert(i);
    }
    for(size_t t_idx=0;t_idx<num_vs-1;t_idx++){
        size_t v1=*(available_idxs.begin());
        available_idxs.erase(v1);
        std::uniform_int_distribution<size_t> pdf(0,available_idxs.size()-1);
        size_t rand_idx=pdf(mpi_utils::prng);
        auto it=available_idxs.begin();
        for(size_t i=0;i<rand_idx;i++){
            ++it;
        }
        size_t v2=(*it);
        if(v1>v2){
            size_t swap=v1;
            v1=v2;
            v2=swap;
        }
        size_t a=available_idxs.erase(v2);
        available_idxs.insert(virt_site_counter);
        virt_site_counter++;
        size_t depth=((vs[v1].depth()>vs[v2].depth())?vs[v1].depth():vs[v2].depth())+1;
        
        //note the rescaling, for the bimodal case which can only be generated by discrete_distribution returning 0 or 1
        //input distributions should be scaled appropriately!
        size_t r_i=vs[v1].rank();
        size_t r_j=vs[v2].rank();
        size_t r_k=(r_i*r_j>r_max)?r_max:r_i*r_j;
        if(t_idx==num_tensors-1){ //for the top tensor
            if(tdim!=0){ //tdim==0 means it was not specified
                r_k=tdim;
            }
        }
        vs.push_back(site(r_k,vs[v1].vol()+vs[v2].vol(),depth,v1,v2));
        vs[vs.size()-1].p_k()=std::vector<double>(r_k,1/(double) r_k);
        
        array3d<double> w(r_i,r_j,r_k); //bond is still as weight matrix
        std::vector<double> sum_addends;
        for(size_t i=0;i<r_i;i++){
            for(size_t j=0;j<r_j;j++){
                for(size_t k=0;k<r_k;k++){
                    w.at(i,j,k)=unif_dist(mpi_utils::prng);
                    sum_addends.push_back(w.at(i,j,k));
                }
            }
        }
        double sum=vec_add_float(sum_addends);
        for(size_t i=0;i<r_i;i++){
            for(size_t j=0;j<r_j;j++){
                for(size_t k=0;k<r_k;k++){
                    w.at(i,j,k)/=sum;
                }
            }
        }
        bond b(v1,v2,depth,w);
        b.order()=num_vs+t_idx;
        b.virt_count()=vs[v1].virt()+vs[v2].virt();
        b.todo()=0;
        b.bmi()=std::numeric_limits<double>::quiet_NaN();
        es.insert(b);
        vs[vs.size()-1].p_bond()=b;
        vs[v1].u_idx()=vs.size()-1;
        vs[v2].u_idx()=vs.size()-1;
        // std::cout<<(std::string) b<<"\n";g.vs()[current.v1()].p_k()
    }
    vs[vs.size()-1].u_idx()=0;
    vs[vs.size()-1].bmi()=std::numeric_limits<double>::quiet_NaN();
    
    graph<cmp> g(vs,es);
    g.n_phys_sites()=num_vs;
    // std::cout<<(std::string) g<<"\n";
    // exit(1);
    return g;
}
template graph<bmi_comparator> graph_utils::init_rand(size_t,size_t,size_t,std::vector<size_t>);

template<typename cmp>
graph<cmp> graph_utils::init_rand(size_t idim,size_t r_max,std::vector<size_t> ls){
    return graph_utils::init_rand<cmp>(idim,0,r_max,ls);
}
template graph<bmi_comparator> graph_utils::init_rand(size_t,size_t,std::vector<size_t>);