/*
Copyright 2025 Katsuya O. Akamatsu

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <cmath>
#include <iostream>
#include <sstream>
#include <fstream>
#include <chrono>
#include <tuple>

#include "bond.hpp"
#include "graph_utils.hpp"
#include "site.hpp"
#include "utils.hpp"

template<typename cmp>
graph<cmp> graph_utils::init_pbttn(int idim,int tdim,int r_max,int num_vs){
    std::uniform_real_distribution<> unif_dist(1e-10,1.0);
    std::vector<site> vs;
    std::multiset<bond,cmp> es{cmp(idim)};
    for(int v1=0;v1<num_vs;v1++){
        vs.push_back(site(idim,1));
        vs[v1].p_k()=std::vector<double>(idim,1/(double) idim);
    }
    
    int num_tensors=num_vs-1;
    int counter=0;
    for(int t_idx=0;t_idx<num_tensors;t_idx++){
        int v1=counter;
        int v2=counter+1;
        
        //note the rescaling, for the bimodal case which can only be generated by discrete_distribution returning 0 or 1
        //input distributions should be scaled appropriately!
        int r_i=vs[v1].rank();
        int r_j=vs[v2].rank();
        int r_k=(r_i*r_j>r_max)?r_max:r_i*r_j;
        if(t_idx==num_tensors-1){ //for the top tensor
            if(tdim!=0){ //tdim==0 means it was not specified
                r_k=tdim;
            }
        }
        int depth=((vs[v1].depth()>vs[v2].depth())?vs[v1].depth():vs[v2].depth())+1;
        vs.push_back(site(r_k,vs[v1].vol()+vs[v2].vol(),depth,v1,v2));
        vs[vs.size()-1].p_k()=std::vector<double>(r_k,1/(double) r_k);
        
        array3d<double> w(r_i,r_j,r_k); //bond is still as weight matrix
        double sum=0;
        for(int i=0;i<r_i;i++){
            for(int j=0;j<r_j;j++){
                for(int k=0;k<r_k;k++){
                    w.at(i,j,k)=unif_dist(prng);
                    sum+=w.at(i,j,k);
                }
            }
        }
        for(int i=0;i<r_i;i++){
            for(int j=0;j<r_j;j++){
                for(int k=0;k<r_k;k++){
                    w.at(i,j,k)/=sum;
                }
            }
        }
        bond b(v1,v2,depth,w);
        b.order()=num_vs+t_idx;
        b.todo()=0;
        b.bmi()=std::numeric_limits<double>::quiet_NaN();
        b.ee()=std::numeric_limits<double>::quiet_NaN();
        es.insert(b);
        vs[vs.size()-1].p_bond()=b;
        vs[v1].u_idx()=vs.size()-1;
        vs[v2].u_idx()=vs.size()-1;
        
        counter+=2;
    }
    vs[vs.size()-1].u_idx()=0;
    vs[vs.size()-1].bmi()=std::numeric_limits<double>::quiet_NaN();
    vs[vs.size()-1].ee()=std::numeric_limits<double>::quiet_NaN();
    
    graph<cmp> g(vs,es);
    g.n_phys_sites()=num_vs;
    // std::cout<<(std::string) g<<"\n";
    return g;
}
template graph<bmi_comparator> graph_utils::init_pbttn(int,int,int,int);

template<typename cmp>
graph<cmp> graph_utils::init_pbttn(int idim,int r_max,int l){
    return graph_utils::init_pbttn<cmp>(idim,0,r_max,l);
}
template graph<bmi_comparator> graph_utils::init_pbttn(int,int,int);

template<typename cmp>
graph<cmp> graph_utils::init_mps(int idim,int tdim,int r_max,int num_vs){
    std::uniform_real_distribution<> unif_dist(1e-10,1.0);
    std::vector<site> vs;
    std::multiset<bond,cmp> es{cmp(idim)};
    for(int v1=0;v1<num_vs;v1++){
        vs.push_back(site(idim,1));
        vs[v1].p_k()=std::vector<double>(idim,1/(double) idim);
    }
    
    int num_tensors=num_vs-1;
    int phys_site_counter=0;
    int virt_site_counter=num_vs-1;
    int depth=1;
    for(int t_idx=0;t_idx<num_vs-1;t_idx++){
        int v1=phys_site_counter;
        int v2=(t_idx==0)?++phys_site_counter:virt_site_counter;
        
        //note the rescaling, for the bimodal case which can only be generated by discrete_distribution returning 0 or 1
        //input distributions should be scaled appropriately!
        int r_i=vs[v1].rank();
        int r_j=vs[v2].rank();
        int r_k=(r_i*r_j>r_max)?r_max:r_i*r_j;
        if(t_idx==num_tensors-1){ //for the top tensor
            if(tdim!=0){ //tdim==0 means it was not specified
                r_k=tdim;
            }
        }
        vs.push_back(site(r_k,vs[v1].vol()+vs[v2].vol(),depth,v1,v2));
        vs[vs.size()-1].p_k()=std::vector<double>(r_k,1/(double) r_k);
        
        array3d<double> w(r_i,r_j,r_k); //bond is still as weight matrix
        double sum=0;
        for(int i=0;i<r_i;i++){
            for(int j=0;j<r_j;j++){
                for(int k=0;k<r_k;k++){
                    w.at(i,j,k)=unif_dist(prng);
                    sum+=w.at(i,j,k);
                }
            }
        }
        for(int i=0;i<r_i;i++){
            for(int j=0;j<r_j;j++){
                for(int k=0;k<r_k;k++){
                    w.at(i,j,k)/=sum;
                }
            }
        }
        bond b(v1,v2,depth,w);
        b.order()=num_vs+t_idx;
        b.todo()=0;
        b.bmi()=std::numeric_limits<double>::quiet_NaN();
        b.ee()=std::numeric_limits<double>::quiet_NaN();
        es.insert(b);
        vs[vs.size()-1].p_bond()=b;
        vs[v1].u_idx()=vs.size()-1;
        vs[v2].u_idx()=vs.size()-1;
        
        phys_site_counter++;
        virt_site_counter++;
        depth++;
    }
    vs[vs.size()-1].u_idx()=0;
    vs[vs.size()-1].bmi()=std::numeric_limits<double>::quiet_NaN();
    vs[vs.size()-1].ee()=std::numeric_limits<double>::quiet_NaN();
    
    graph<cmp> g(vs,es);
    g.n_phys_sites()=num_vs;
    // std::cout<<(std::string) g<<"\n";
    return g;
}
template graph<bmi_comparator> graph_utils::init_mps(int,int,int,int);

template<typename cmp>
graph<cmp> graph_utils::init_mps(int idim,int r_max,int l){
    return graph_utils::init_mps<cmp>(idim,0,r_max,l);
}
template graph<bmi_comparator> graph_utils::init_mps(int,int,int);

template<typename cmp>
graph<cmp> graph_utils::init_rand(int idim,int tdim,int r_max,int num_vs){
    std::uniform_real_distribution<> unif_dist(1e-10,1.0);
    std::vector<site> vs;
    std::multiset<bond,cmp> es{cmp(idim)};
    for(int v1=0;v1<num_vs;v1++){
        vs.push_back(site(idim,1));
        vs[v1].p_k()=std::vector<double>(idim,1/(double) idim);
        vs[v1].depth()=0;
    }
    
    int num_tensors=num_vs-1;
    int virt_site_counter=num_vs;
    std::set<int> available_idxs;
    for(int i=0;i<num_vs;i++){
        available_idxs.insert(i);
    }
    for(int t_idx=0;t_idx<num_vs-1;t_idx++){
        int v1=*(available_idxs.begin());
        available_idxs.erase(v1);
        std::uniform_int_distribution<int> pdf(0,available_idxs.size()-1);
        int rand_idx=pdf(prng);
        auto it=available_idxs.begin();
        for(int i=0;i<rand_idx;i++){
            ++it;
        }
        int v2=(*it);
        if(v1>v2){
            int swap=v1;
            v1=v2;
            v2=swap;
        }
        int a=available_idxs.erase(v2);
        available_idxs.insert(virt_site_counter);
        virt_site_counter++;
        int depth=((vs[v1].depth()>vs[v2].depth())?vs[v1].depth():vs[v2].depth())+1;
        
        //note the rescaling, for the bimodal case which can only be generated by discrete_distribution returning 0 or 1
        //input distributions should be scaled appropriately!
        int r_i=vs[v1].rank();
        int r_j=vs[v2].rank();
        int r_k=(r_i*r_j>r_max)?r_max:r_i*r_j;
        if(t_idx==num_tensors-1){ //for the top tensor
            if(tdim!=0){ //tdim==0 means it was not specified
                r_k=tdim;
            }
        }
        vs.push_back(site(r_k,vs[v1].vol()+vs[v2].vol(),depth,v1,v2));
        vs[vs.size()-1].p_k()=std::vector<double>(r_k,1/(double) r_k);
        
        array3d<double> w(r_i,r_j,r_k); //bond is still as weight matrix
        double sum=0;
        for(int i=0;i<r_i;i++){
            for(int j=0;j<r_j;j++){
                for(int k=0;k<r_k;k++){
                    w.at(i,j,k)=unif_dist(prng);
                    sum+=w.at(i,j,k);
                }
            }
        }
        for(int i=0;i<r_i;i++){
            for(int j=0;j<r_j;j++){
                for(int k=0;k<r_k;k++){
                    w.at(i,j,k)/=sum;
                }
            }
        }
        bond b(v1,v2,depth,w);
        b.order()=num_vs+t_idx;
        b.todo()=0;
        b.bmi()=std::numeric_limits<double>::quiet_NaN();
        b.ee()=std::numeric_limits<double>::quiet_NaN();
        es.insert(b);
        vs[vs.size()-1].p_bond()=b;
        vs[v1].u_idx()=vs.size()-1;
        vs[v2].u_idx()=vs.size()-1;
    }
    vs[vs.size()-1].u_idx()=0;
    vs[vs.size()-1].bmi()=std::numeric_limits<double>::quiet_NaN();
    vs[vs.size()-1].ee()=std::numeric_limits<double>::quiet_NaN();
    
    graph<cmp> g(vs,es);
    g.n_phys_sites()=num_vs;
    // std::cout<<(std::string) g<<"\n";
    return g;
}
template graph<bmi_comparator> graph_utils::init_rand(int,int,int,int);

template<typename cmp>
graph<cmp> graph_utils::init_rand(int idim,int r_max,int l){
    return graph_utils::init_rand<cmp>(idim,0,r_max,l);
}
template graph<bmi_comparator> graph_utils::init_rand(int,int,int);