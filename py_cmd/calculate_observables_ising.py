import numpy as np
import scipy.special as spspec
import sys,copy,os,time
import itertools
import argparse

import graph_cmd

r_k=2 #TEMP rank of upstream virtual sites
# s_vals=[0,1]
s_vals=[1,-1]
def f(site1,s1,site2,s2): #DEFAULT confluent mapping function reducing to old method
	#s1,s2 are 0,1
	return s1 if site1.vol>=site2.vol else s2
	# return 0 if s1==s2 else 1

parser=argparse.ArgumentParser()
parser.add_argument("input")
parser.add_argument("output")
args=parser.parse_args()

file=args.input
data=np.load(file,allow_pickle=True)
stats=[]
times=[]
for file in data.files:
	start=time.time()
	beta=data[file][0]
	bonds=data[file][1]
	sites=data[file][2]
	n_sites=len(sites)
	n_phys_sites=len([sites[i] for i in range(len(sites)) if not sites[i].virtual_flag])
	
	# print(sites)
	# print(bonds)

	#build adjacency list, this actually stores the triangular plaquettes generated by the cmd, id is the upstream site
	adj=[[i,[],[],None] for i in range(n_sites)] #adj[i][0] is site idx, adj[i][1] is the upstream site, adj[i][2] are the downstream sites, adj[i][3] is the bond idx associated with the plaquette
	for i in range(len(bonds)):
		adj[bonds[i].v1][1].append(bonds[i].up)
		adj[bonds[i].v2][1].append(bonds[i].up)
		adj[bonds[i].up][2].append(bonds[i].v1)
		adj[bonds[i].up][2].append(bonds[i].v2)
		adj[bonds[i].up][3]=i
	# print(adj)
	#find root
	root=[i for i in range(len(adj)) if len(adj[i][1])==0][0]
	# print("root site:",root)
	
	# for b in bonds:
		# b.j=100
		
	moments={}
	known_factors={}
					
	#paper by kelleher and sullivan, 2014
	#code from https://jeromekelleher.net/tag/integer-partitions.html
	def accel_asc(n):
		a=[0 for i in range(n + 1)]
		k=1
		y=n-1
		while k!=0:
			x=a[k-1]+1
			k-=1
			while 2*x<=y:
				a[k]=x
				y-=x
				k+=1
			l=k+1
			while x<=y:
				a[k]=x
				a[l]=y
				yield a[:k+2]
				x+=1
				y-=1
			a[k]=x+y
			y=x+y-1
			yield a[:k+1]
			
	def sum_coef(c,n):
		res=1
		for i in c:
			res*=spspec.binom(n,i)
			n-=i
		return res
	
	#knuth algorithm L
	#code from https://stackoverflow.com/questions/12836385/how-can-i-interleave-or-create-unique-permutations-of-two-strings-without-recur/12837695#12837695
	def unique_permutations(a):
		a=sorted(a)
		while True:
			yield a
			for i in range(len(a)-2,-1,-1):
				if a[i]<a[i+1]:
					break
			else: #for-else is a thing apparently
				return
			i_val=a[i]
			for j in range(len(a)-1,-1,-1):
				if i_val<a[j]:
					break
			(a[i],a[j])=(a[j],a[i])
			a[i+1:]=a[-1:i:-1]
			
	#only works for ising spins
	#TODO: extend to potts spins: m_k^(n,1) is a vector when n odd, scalar when n even
	def m_old(root,s,n,k=1,orig_root=None):
		assert k==1
		if orig_root is None:
			orig_root=root
		#compute desired quantity
		if len(adj[root][2])==0: #leaves
			# print("leaf:",(root,s,n,k),(s_vals[s]**n)**k)
			# print(root,s,n,k)
			return (s_vals[s]**n)
			# return np.sum([p(s,s_idx,j)*(s_vals[s_idx]**n) for s_idx in range(len(s_vals))])**k
			# return np.asarray([(s_vals[s]**n)**k])
		else:
			res=0
			#compute weights for summation at a plaquette, given upstream spin s
			p_ij=np.zeros(bonds[adj[root][3]].w.shape)
			for j in range(p_ij.shape[1]):
				for i in range(p_ij.shape[0]):
					p_ij[j,i]=bonds[adj[root][3]].w[j,i] if f(sites[adj[root][2][0]],i,sites[adj[root][2][1]],j)==s else 0
			p_ij*=r_k
			p_i=np.sum(p_ij,axis=0)
			p_j=np.sum(p_ij,axis=1)
			p_child=np.asarray([p_i,p_j])
			#subtree contributions
			c_res=0
			for down in range(len(adj[root][2])):
				# print(down,root,orig_root)
				a=0
				for s_idx in range(p_child[down].shape[0]):
					if not (adj[root][2][down],s_idx,n,k) in known_factors:
						contrib=m_old(adj[root][2][down],s_idx,n,k,orig_root=orig_root)
						known_factors[(adj[root][2][down],s_idx,n,k)]=contrib
					else:
						contrib=known_factors[(adj[root][2][down],s_idx,n,k)]
					a+=p_child[down][s_idx]*contrib
				# a=np.sum([p_child[down][s_idx]*m(adj[root][2][down],s_idx,n,k,orig_root=orig_root) for s_idx in range(p_child[down].shape[0])]) #need to get weighted average over p_child (tracing out other child)
				if root==orig_root:
					print("subtree %d:"%down,a)
				c_res+=a
			if root==orig_root:
				print("c_res (subtrees):",c_res)
			res+=c_res
			#cross-subtree contributions
			compositions=accel_asc(n)
			for c in compositions:
				if len(c)==1: #subtree contributions already handled
					continue
				c_res=0
				len_c=len(c)
				coef=sum_coef(c,n)
				for comb in itertools.combinations(adj[root][2],len_c):
					# print(comb)
					childs=copy.deepcopy(comb)
					factors=[0 for i in range(len_c)]
					for perm in unique_permutations(c):
						for spins in itertools.product(range(len(s_vals)),repeat=len_c):
							for i in range(len_c):
								if not (childs[i],spins[-1-i],perm[i],k) in known_factors:
									factors[i]=m_old(childs[i],spins[-1-i],perm[i],k,orig_root=orig_root)
									known_factors[(childs[i],spins[-1-i],perm[i],k)]=factors[i]
								else:
									factors[i]=known_factors[(childs[i],spins[-1-i],perm[i],k)]
							weight=p_ij[spins]
							# if root==orig_root:
								# print(comb,perm,coef,spins,weight,factors,np.prod(factors))
							c_res+=coef*weight*(np.prod(factors))
				if root==orig_root:
					print("c_res:",c,coef,c_res)
				res+=c_res
			if root==orig_root:
				print("res:",root,res,np.sum(res))
			return res
	
	#only works for ising spins
	#TODO: extend to potts spins: m_k^(n,1) is a vector when n odd, scalar when n even
	def m(root,n,p,c,orig_root=None):
		assert np.sum(c)==p
		if orig_root is None:
			orig_root=root
		#compute desired quantity
		if len(adj[root][2])==0: #leaves
			return np.prod([s_vals[i]**(n*c[i]) for i in range(r_k)])
		else:
			res=0
			#compute weights for summation at a plaquette, given upstream spin s
			p_ij=np.zeros(list(bonds[adj[root][3]].w.shape)+[r_k])
			for k in range(p_ij.shape[2]):
				for j in range(p_ij.shape[1]):
					for i in range(p_ij.shape[0]):
						p_ij[i,j,k]=bonds[adj[root][3]].w[i,j] if f(sites[adj[root][2][0]],i,sites[adj[root][2][1]],j)==k else 0
			p_ij*=r_k
			p_i=np.sum(p_ij,axis=1)
			p_j=np.sum(p_ij,axis=0)
			p_child=np.asarray([p_i,p_j])
			q_idxs=[]
			for i in range(len(c)):
				for j in range(c[i]):
					q_idxs.append(i)
			#subtree contributions
			c_res=0
			for down in range(len(adj[root][2])):
				a=0
				for spins in itertools.product(range(bonds[adj[root][3]].w.shape[0]),repeat=p):
					c_vals=tuple(np.bincount(spins,minlength=r_k))
					if not (adj[root][2][down],n,p,c_vals) in known_factors:
						contrib=m(adj[root][2][down],n,p,c_vals,orig_root=orig_root)
						known_factors[(adj[root][2][down],n,p,c_vals)]=contrib
					else:
						contrib=known_factors[(adj[root][2][down],n,p,c_vals)]
					weight=np.prod([p_child[down,spins[i],q_idxs[i]] if p_child[down,spins[i],q_idxs[i]]!=0 else 0 for i in range(p)])
					a+=weight*contrib
				# if root==orig_root:
					# print("subtree %d:"%down,a)
				c_res+=a
			# if root==orig_root:
				# print("c_res (subtrees):",c_res)
			res+=c_res
			#cross-subtree contributions
			compositions=accel_asc(n)
			for c in compositions:
				if len(c)==1: #subtree contributions already handled
					continue
				c_res=0
				len_c=len(c)
				coef=sum_coef(c,n)
				for comb in itertools.combinations(adj[root][2],len_c):
					childs=copy.deepcopy(comb)
					factors=[0 for i in range(len_c)]
					for perm in unique_permutations(c):
						for spins1 in itertools.product(range(bonds[adj[root][3]].w.shape[0]),repeat=p):
							for spins2 in itertools.product(range(bonds[adj[root][3]].w.shape[1]),repeat=p):
								spins=[spins1,spins2] #TEMPORARY
								c_vals=[tuple(np.bincount(spins[i],minlength=r_k)) for i in range(r_k)]
								for i in range(len_c):
									if not (childs[i],perm[i],p,c_vals[i]) in known_factors:
										factors[i]=m(childs[i],perm[i],p,c_vals[i],orig_root=orig_root)
										known_factors[(childs[i],perm[i],p,c_vals[i])]=factors[i]
									else:
										factors[i]=known_factors[(childs[i],perm[i],p,c_vals[i])]
								weight=np.prod([p_ij[spins1[i],spins2[i],q_idxs[i]] if p_ij[spins1[i],spins2[i],q_idxs[i]]!=0 else 0 for i in range(p)])
								# if root==orig_root:
									# print(comb,perm,coef,spins,weight,factors,np.prod(factors))
								c_res+=coef*weight*(np.prod(factors))
				# if root==orig_root:
					# print("c_res:",c,coef,c_res)
				res+=c_res
			# if root==orig_root:
				# print("res:",root,res,np.sum(res))
			return res
			
	# m11=m_old(root,0,1)
	# print("<si> (old):",m11,m11/(n_phys_sites))
	# m11=m(root,1,1,(1,0))
	# print("<si>:",m11,m11/(n_phys_sites))
	# print("")
	# m12=m(root,1,2,(2,0))
	# print("<si>^2:",m12,m12/(n_phys_sites))
	# print("")
	# m21=m_old(root,0,2)
	# print("<si sj> (old):",m21,m21/(n_phys_sites**2))
	# m21=m(root,2,1,(1,0))
	# print("<si sj>:",m21,m21/(n_phys_sites**2))
	# print("")
	# m22=m(root,2,2,(2,0))
	# print("<si sj>^2:",m22,m22/(n_phys_sites**2))
	# print("")
	# m31=m_old(root,0,3)
	# print("<si sj sk> (old):",m31,m31/(n_phys_sites**3))
	# m31=m(root,3,1,(1,0))
	# print("<si sj sk>:",m31,m31/(n_phys_sites**3))
	# print("")
	# m41=m_old(root,0,4)
	# print("<si sj sk sl> (old):",m41,m41/(n_phys_sites**4))
	# m41=m(root,4,1,(1,0))
	# print("<si sj sk sl>:",m41,m41/(n_phys_sites**4))
	# print("")
	# m42=m(root,4,2,(2,0))
	# print("<si sj sk sl>^2:",m42,m42/(n_phys_sites**4))
	# print("")
	
	q2=m(root,2,2,(2,0))/(n_phys_sites**2)
	q4=m(root,4,2,(2,0))/(n_phys_sites**4)
	q=np.sqrt(q2)
	q2_var=q4-(q2**2)
	q2_std=np.sqrt(q2_var)
	sus_sg=n_phys_sites*q2
	binder_q=0.5*(3-(q4/(q2**2)))
	print(beta,q2,q4)
	print(q2,q,sus_sg,q2_std,binder_q)
	print("")
	# stats.append((beta,q2,q,sus_sg))
	stats.append((beta,q2,q,sus_sg,q2_std,binder_q))
	# print(beta,q2,q,sus_sg)
	end=time.time()
	elapsed=end-start
	times.append(elapsed)
	print("Time elapsed for this beta: %f s"%times[-1])
	# sys.exit(0)

print("Total time elapsed for this run: %f s"%np.sum(times))
print("Average time elapsed for this run per beta: %f+/-%f s"%(np.mean(times),np.std(times)))
path=os.path.split(args.output)[0]
if path!="" and not os.path.exists(path):
	os.mkdir(os.path.split(args.output)[0])
out=open(args.output,"w")
# out.write("beta q2 q sus_sg\n")
out.write("beta q2 q sus_sg q2_std binder_q\n")
for i in range(len(stats)):
	# out.write("%f %f %f %f\n"%stats[i])
	out.write("%f %f %f %f %f %f\n"%stats[i])
out.close()
