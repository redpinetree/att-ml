#include <cmath>
#include <iostream>
#include <sstream>
#include <fstream>
#include <chrono>

#include "graph_utils.hpp"
#include "../mpi_utils.hpp"
#include "../site.hpp"
#include "bond.hpp"

template<typename distribution,typename cmp>
graph<cmp> graph_utils::gen_hypercubic(size_t q,std::vector<size_t> ls,bool pbc,distribution& dist,double beta){
    size_t d=ls.size();
    std::vector<site> vs;
    std::multiset<bond,cmp> es{cmp(q)};
    size_t num_vs=1;
    for(size_t i=0;i<ls.size();i++){
        num_vs*=ls[i];
    }
    for(size_t v1=0;v1<num_vs;v1++){
        vs.push_back(site(q,1));
    }
    for(size_t v1=0;v1<num_vs;v1++){
        size_t v1_idx=v1;
        //identify position of site v1 on hypercubic lattice
        std::vector<size_t> base_coords;
        for(size_t d_idx=0;d_idx<d;d_idx++){
            base_coords.push_back(v1_idx%ls[d_idx]);
            v1_idx/=ls[d_idx];
        }
        vs[v1].coords()=base_coords;
        //add offset (+1 for nearest neighbor)
        for(size_t d_idx=0;d_idx<d;d_idx++){
            //boundary condition
            if(!pbc && (base_coords[d_idx]+1)>=ls[d_idx]){
                continue;
            }
            std::vector<size_t> offsets=base_coords;
            offsets[d_idx]=(offsets[d_idx]+1)%ls[d_idx];
            //compute idx of v2
            size_t v2=0;
            for(size_t d_idx2=d;d_idx2>0;d_idx2--){
                v2=(v2*ls[d_idx2-1])+offsets[d_idx2-1];
            }
            //note the rescaling, for the bimodal case which can only be generated by discrete_distribution returning 0 or 1
            //input distributions should be scaled appropriately!
            double k=(2*dist(mpi_utils::prng))-1;
            k*=beta;
            array2d<double> w(q,q); //bond is still as weight matrix
            for(size_t i=0;i<q;i++){
                for(size_t j=0;j<q;j++){
                    w.at(i,j)=(i==j)?(1/(q+(q*(q-1)*exp(-k)))):(1/((q*exp(k))+(q*(q-1))));
                }
            }
            es.insert(bond(v1,v2,w));
            vs[v1].adj().insert(bond(v1,v2,w));
            vs[v2].adj().insert(bond(v1,v2,w));
        }
    }
    graph<cmp> g(vs,es);
    g.dims()=ls;
    return g;
}
template graph<bmi_comparator> graph_utils::gen_hypercubic<std::normal_distribution<double>,bmi_comparator>(size_t,std::vector<size_t>,bool,std::normal_distribution<double>&,double);
template graph<bmi_comparator> graph_utils::gen_hypercubic<std::discrete_distribution<int>,bmi_comparator>(size_t,std::vector<size_t>,bool,std::discrete_distribution<int>&,double);
template graph<bmi_comparator> graph_utils::gen_hypercubic<std::uniform_real_distribution<double>,bmi_comparator>(size_t,std::vector<size_t>,bool,std::uniform_real_distribution<double>&,double);

//only for potts model... should have new format to store weight matrices too
template<typename cmp>
graph<cmp> graph_utils::load_graph(std::string fn,size_t q,double beta){
    std::ifstream ifs;
    ifs.open(fn);
    std::string line;
    size_t num_vs,num_es;
    std::vector<site> vs;
    std::multiset<bond,cmp> es{cmp(q)};
    std::getline(ifs,line);
    std::stringstream first_line_ss(line);
    first_line_ss>>num_vs>>num_es;
    for(size_t i=0;i<num_vs;i++){
        vs.push_back(site(q,1));
    }
    while(std::getline(ifs,line)){
        std::stringstream line_ss(line);
        size_t v1,v2;
        double k;
        line_ss>>v1>>v2>>k;
        k/=1e5;
        k*=beta;
        array2d<double> w(q,q); //bond is still as weight matrix
        for(size_t i=0;i<q;i++){
            for(size_t j=0;j<q;j++){
                w.at(i,j)=(i==j)?(1/(q+(q*(q-1)*exp(-k)))):(1/((q*exp(k))+(q*(q-1))));
            }
        }
        es.insert(bond(v1,v2,w));
        vs[v1].adj().insert(bond(v1,v2,w));
        vs[v2].adj().insert(bond(v1,v2,w));
    }
    return graph<cmp>(vs,es);
}
template graph<bmi_comparator> graph_utils::load_graph(std::string,size_t,double);