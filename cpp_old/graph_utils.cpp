#include <cmath>
#include <iostream>
#include <sstream>
#include <fstream>
#include <chrono>

#include "graph_utils.hpp"
#include "site.hpp"
#include "bond.hpp"

std::mt19937 graph_utils::prng((size_t) std::chrono::high_resolution_clock::now().time_since_epoch().count());

template<typename distribution>
graph_old graph_utils::gen_hypercubic_old(size_t q,std::vector<size_t> ls,bool pbc,distribution& dist){
    size_t d=ls.size();
    std::vector<site> vs;
    std::vector<bond> es;
    size_t num_vs=1;
    for(size_t i=0;i<ls.size();i++){
        num_vs*=ls[i];
    }
    for(size_t v1=0;v1<num_vs;v1++){
        vs.push_back(site());
        size_t v1_idx=v1;
        //identify position of site v1 on hypercubic lattice
        std::vector<size_t> base_coords;
        for(size_t d_idx=0;d_idx<d;d_idx++){
            base_coords.push_back(v1_idx%ls[d_idx]);
            v1_idx/=ls[d_idx];
        }
        //add offset (+1 for nearest neighbor)
        for(size_t d_idx=0;d_idx<d;d_idx++){
            //boundary condition
            if(!pbc && (base_coords[d_idx]+1)>=ls[d_idx]){
                continue;
            }
            std::vector<size_t> offsets=base_coords;
            offsets[d_idx]=(offsets[d_idx]+1)%ls[d_idx];
            //compute idx of v2
            size_t v2=0;
            for(size_t d_idx2=d;d_idx2>0;d_idx2--){
                v2=(v2*ls[d_idx2-1])+offsets[d_idx2-1];
            }
            //note the rescaling, for the bimodal case which can only be generated by discrete_distribution returning 0 or 1
            //input distributions should be scaled appropriately!
            double j=(2*dist(prng))-1; 
            es.push_back(bond(q,v1,v2,j));
        }
    }
    return graph_old(vs,es);
}
template graph_old graph_utils::gen_hypercubic_old<std::normal_distribution<double> >(size_t,std::vector<size_t>,bool,std::normal_distribution<double>&);
template graph_old graph_utils::gen_hypercubic_old<std::discrete_distribution<int> >(size_t,std::vector<size_t>,bool,std::discrete_distribution<int>&);
template graph_old graph_utils::gen_hypercubic_old<std::uniform_real_distribution<double> >(size_t,std::vector<size_t>,bool,std::uniform_real_distribution<double>&);

void graph_utils::save_graph_old(std::string fn,graph_old& g){
    std::ofstream ofs;
    ofs.open(fn);
    ofs<<g.vs().size()<<" "<<g.es().size();
    for(size_t i=0;i<g.es().size();i++){
        if(i!=g.es().size()){
            ofs<<"\n";
        }
        ofs<<g.es()[i].v1()<<" "<<g.es()[i].v2()<<" "<<round(g.es()[i].j()*1e5);
    }
    ofs.close();
}

graph_old graph_utils::load_graph_old(std::string fn,size_t q){
    std::ifstream ifs;
    ifs.open(fn);
    std::string line;
    size_t num_vs,num_es;
    std::vector<site> vs;
    std::vector<bond> es;
    std::getline(ifs,line);
    std::stringstream first_line_ss(line);
    first_line_ss>>num_vs>>num_es;
    for(size_t i=0;i<num_vs;i++){
        vs.push_back(site());
    }
    while(std::getline(ifs,line)){
        std::stringstream line_ss(line);
        size_t v1,v2;
        double j;
        line_ss>>v1>>v2>>j;
        //TEMPORARY
        v1-=1;
        v2-=1;
        j/=1e5;
        es.push_back(bond(q,v1,v2,j));
    }
    return graph_old(vs,es);
}